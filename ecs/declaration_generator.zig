const std = @import("std");
const Self = @This();

comp_names: std.StringHashMap(void),
generators: std.ArrayList(*const fn (std.io.AnyWriter) anyerror!void),
outpath: []const u8,
allocator: std.mem.Allocator,

pub fn init(outpath: []const u8, allocator: std.mem.Allocator) Self {
    return .{
        .comp_names = .init(allocator),
        .outpath = outpath,
        .generators = .init(allocator),
        .allocator = allocator,
    };
}

pub fn deinit(self: *Self) void {
    self.generators.deinit();
    self.comp_names.deinit();
}

pub fn registerComponentsForBuild(self: *Self, comptime Comps: anytype) !void {
    inline for (Comps) |c| {
        try self.registerComponentForBuild(c);
    }
}
pub fn registerComponentForBuild(self: *Self, comptime Comp: type) !void {
    try self.generators.append(@ptrCast(&Comp.luaGenerateStubFile));
    if (try self.comp_names.fetchPut(Comp.comp_name, {})) |_| {
        std.debug.print("Component {s} is already registered\n", .{Comp.comp_name});
        return error.componentAlreadyRegistered;
    }
}

fn emitHeader(writer: anytype) anyerror!void {
    try writer.writeAll("-- AUTOGENERATED BY ECS BUILD STEP\n");
    try writer.writeAll("-- DO NOT EDIT\n");
    try writer.writeAll("---@meta\n");
    try writer.writeAll("---@diagnostic disable: unused-local\n\n");
}

fn emitNamespaces(self: *Self, writer: anytype) anyerror!void {
    try writer.writeAll("-- START NAMESPACES\n\n");
    var all_parts = std.ArrayList(std.ArrayList([]const u8)).init(self.allocator);
    defer {
        for (all_parts.items) |part| {
            part.deinit();
        }
        all_parts.deinit();
    }
    var names_iter = self.comp_names.keyIterator();
    while (names_iter.next()) |name| {
        try all_parts.append(.init(self.allocator));
        var scalar_iter = std.mem.splitScalar(u8, name.*, '.');
        while (scalar_iter.next()) |part| {
            try all_parts.items[all_parts.items.len - 1].append(part);
        }
    }
    var already_emitted: std.StringHashMap(void) = .init(self.allocator);
    defer {
        var keys = already_emitted.keyIterator();
        while (keys.next()) |key| {
            self.allocator.free(key.*);
        }
        already_emitted.deinit();
    }
    for (all_parts.items) |parts| {
        var acc: []const u8 = &.{};
        defer if (acc.len > 0) {
            self.allocator.free(acc);
        };
        const skip_last = parts.items.len - 1;
        for (parts.items[0..skip_last], 0..) |part, index| {
            var new_size = acc.len + part.len;
            if (index > 0) {
                new_size += 1;
            }
            var mem = try self.allocator.alloc(u8, new_size);
            @memcpy(mem[0..acc.len], acc);
            if (index == 0) {
                @memcpy(mem[acc.len..], part);
            } else {
                mem[acc.len] = '.';
                @memcpy(mem[(acc.len + 1)..], part);
            }
            if (acc.len > 0) {
                self.allocator.free(acc);
            }
            acc = mem;
            if (already_emitted.contains(acc)) {
                continue;
            }
            // copy memory so the hashmap can free everything without problems
            try already_emitted.put(try self.allocator.dupe(u8, acc), {});
            if (index == 0) {
                try writer.writeAll("local ");
            }
            try writer.print("{s} = {{}}\n", .{acc});
        }
    }
    try writer.writeAll("\n-- END NAMESPACES\n\n");
}

pub fn generate(self: *Self) anyerror!void {
    const cwd = std.fs.cwd();
    var file = try cwd.createFile(
        self.outpath,
        .{ .truncate = true },
    );
    defer file.close();
    const writer = file.writer();
    try emitHeader(writer);
    try self.emitNamespaces(writer);
    try writer.writeAll("-- START TYPES\n\n");
    for (self.generators.items) |func| {
        try func(writer.any());
    }
    try writer.writeAll("\n-- END TYPES\n\n");
    try writer.writeAll("\n---@diagnostic enable: unused-local");
}
