const std = @import("std");
const Self = @This();

comp_names: std.StringHashMap(void),
generators: std.ArrayList(*const fn (std.io.AnyWriter) anyerror!void),
types_path: []const u8,
components_path: []const u8,
allocator: std.mem.Allocator,

pub fn init(types_path: []const u8, components_path: []const u8, allocator: std.mem.Allocator) Self {
    return .{
        .comp_names = .init(allocator),
        .types_path = types_path,
        .generators = .init(allocator),
        .components_path = components_path,
        .allocator = allocator,
    };
}

pub fn deinit(self: *Self) void {
    self.generators.deinit();
    self.comp_names.deinit();
}

pub fn registerComponentsForBuild(self: *Self, comptime Comps: anytype) !void {
    inline for (Comps) |c| {
        try self.registerComponentForBuild(c);
    }
}
pub fn registerComponentForBuild(self: *Self, comptime Comp: type) !void {
    try self.generators.append(@ptrCast(&Comp.luaGenerateStubFile));
    if (try self.comp_names.fetchPut(Comp.comp_name, {})) |_| {
        std.debug.print("Component {s} is already registered\n", .{Comp.comp_name});
        return error.componentAlreadyRegistered;
    }
}

fn emitTypesHeader(writer: std.io.AnyWriter) anyerror!void {
    try writer.writeAll("-- AUTOGENERATED BY ECS BUILD STEP\n");
    try writer.writeAll("-- DO NOT EDIT\n");
    try writer.writeAll("---@meta\n");
    try writer.writeAll("---@diagnostic disable: unused-local\n\n");
}

fn emitDataHeader(writer: std.io.AnyWriter) anyerror!void {
    try writer.writeAll("-- AUTOGENERATED BY ECS BUILD STEP\n");
    try writer.writeAll("-- DO NOT EDIT\n");
    try writer.writeAll("---@diagnostic disable: unused-local\n");
    try writer.writeAll("---@diagnostic disable: missing-fields\n\n");
}

fn emitNamespaces(self: *Self, writer: std.io.AnyWriter) anyerror!std.ArrayList([]const u8) {
    var top_level_namespaces: std.ArrayList([]const u8) = .init(self.allocator);
    try writer.writeAll("-- START NAMESPACES\n\n");
    var all_parts = std.ArrayList(std.ArrayList([]const u8)).init(self.allocator);
    defer {
        for (all_parts.items) |part| {
            part.deinit();
        }
        all_parts.deinit();
    }
    var names_iter = self.comp_names.keyIterator();
    while (names_iter.next()) |name| {
        try all_parts.append(.init(self.allocator));
        var scalar_iter = std.mem.splitScalar(u8, name.*, '.');
        while (scalar_iter.next()) |part| {
            try all_parts.items[all_parts.items.len - 1].append(part);
        }
    }
    var already_emitted: std.StringHashMap(void) = .init(self.allocator);
    defer {
        var keys = already_emitted.keyIterator();
        while (keys.next()) |key| {
            self.allocator.free(key.*);
        }
        already_emitted.deinit();
    }
    for (all_parts.items) |parts| {
        var acc: []const u8 = &.{};
        defer if (acc.len > 0) {
            self.allocator.free(acc);
        };
        const skip_last = parts.items.len - 1;
        for (parts.items[0..skip_last], 0..) |part, index| {
            var new_size = acc.len + part.len;
            if (index > 0) {
                new_size += 1;
            }
            var mem = try self.allocator.alloc(u8, new_size);
            @memcpy(mem[0..acc.len], acc);
            if (index == 0) {
                @memcpy(mem[acc.len..], part);
            } else {
                mem[acc.len] = '.';
                @memcpy(mem[(acc.len + 1)..], part);
            }
            if (acc.len > 0) {
                self.allocator.free(acc);
            }
            acc = mem;
            if (already_emitted.contains(acc)) {
                continue;
            }
            // copy memory so the hashmap can free everything without problems
            try already_emitted.put(try self.allocator.dupe(u8, acc), {});
            if (index == 0) {
                const copied = try self.allocator.dupe(u8, acc);
                try top_level_namespaces.append(copied);
            }
            try writer.print("{s} = {{}}\n", .{acc});
        }
    }
    try writer.writeAll("\n-- END NAMESPACES\n\n");
    return top_level_namespaces;
}

pub fn generateTypesFile(self: *Self, writer: std.io.AnyWriter) anyerror!void {
    try emitTypesHeader(writer);
    const ret = try self.emitNamespaces(writer);
    for (ret.items) |s| {
        self.allocator.free(s);
    }
    ret.deinit();
    try writer.writeAll("-- START TYPES\n\n");
    for (self.generators.items) |func| {
        try func(writer);
    }
    try writer.writeAll("\n-- END TYPES\n\n");
    try writer.writeAll("\n---@diagnostic enable: unused-local");
}

pub fn generateDataFiles(self: *Self, writer: std.io.AnyWriter) anyerror!void {
    try emitDataHeader(writer);
    const top_level = try self.emitNamespaces(writer);
    defer {
        for (top_level.items) |s| {
            self.allocator.free(s);
        }
        top_level.deinit();
    }
    try writer.writeAll("-- START TYPES\n\n");
    try writer.writeAll("\n-- END TYPES\n\n");

    // we need to emit return and then all the namespaces

    try writer.writeAll("\n---@diagnostic enable: unused-local");
    try writer.writeAll("\n---@diagnostic enable: missing-fields\n\n");
    try writer.writeAll("return {\n");
    for (top_level.items) |item| {
        try writer.print("\t{s} = {s},\n", .{ item, item });
    }
    try writer.writeAll("}");
}

pub fn generate(self: *Self) anyerror!void {
    const cwd = std.fs.cwd();

    var file = try cwd.createFile(
        self.types_path,
        .{ .truncate = true },
    );
    defer file.close();
    const writer = file.writer();

    var components_file = try cwd.createFile(
        self.components_path,
        .{ .truncate = true },
    );
    defer components_file.close();
    const components_writer = components_file.writer();

    try self.generateTypesFile(writer.any());
    try self.generateDataFiles(components_writer.any());
}
